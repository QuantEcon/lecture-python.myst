---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

(fixed_points)=
```{raw} html
<div id="qe-notebook-header" align="right" style="text-align:right;">
        <a href="https://quantecon.org/" title="quantecon.org">
                <img style="width:250px;display:inline;" width="250px" src="https://assets.quantecon.org/img/qe-menubar-logo.svg" alt="QuantEcon">
        </a>
</div>
```
```{index} single: python
```

# Fast Fixed Point Computation Using Gradient Methods

```{contents} Contents
:depth: 2
```

## Overview

The lecture describes application of Newton's method to calculate fixed points in one-dimentional and multi-dimentional settings. 

We consider an easy, one-dimensional fixed point problem where we know the solution first.

We will compute it by both successive approximation and Newton's method.

Then we will generalise Newton's method to a multi-dimentional setting.

The objective is to practice Python coding and investigate these algorithms.

We recall that, to find the fixed point of scalar function $g$, Newton's method iterates on 


```{math}
:label: newtons_method
x_{t+1} = \frac{g(x_t) - g'(x_t) x_t}{ 1 - g'(x_t) },
\qquad x_0 \text{ given}
```

We use the following imports

```{code-cell} python3
import numpy as np
import matplotlib.pyplot as plt
from collections import namedtuple
```


## The Solow Model

Assuming Cobb-Douglas production technology, the law of motion for capital is

```{math}
:label: motion_law
k_{t+1} = sAk_t^\alpha + (1-\delta) k_t
```

We store the parameters in a `namedtuple`

```{code-cell} python3
SolowParameters = namedtuple("SolowParameters", ('A', 's', 'α', 'δ'))
```

This function creates a `namedtuple` of the right type and has default parameter values.


```{code-cell} python3
def create_solow_params(A=2.0, s=0.3, α=0.3, δ=0.4):
    "Creates a Solow model parameterization with default values."
    return SolowParameters(A=A, s=s, α=α, δ=δ)
```

The next two functions describe the law of motion and the true fixed point $k^*$.

```{code-cell} python3
def g(k, params):
    A, s, α, δ = params
    return A * s * k**α + (1 - δ) * k
    
def exact_fixed_point(params):
    A, s, α, δ = params
    return ((s * A) / δ)**(1/(1 - α))
```
Here is a function to provide a 45 degree plot of the dynamics.

```{code-cell} python3
def plot_45(params, ax, fontsize=14):
    
    k_min, k_max = 0, 3
    k_grid = np.linspace(k_min, k_max, 1200)

    # Plot the functions
    lb = r"$g(k) = sAk^{\alpha} + (1 - \delta)k$"
    ax.plot(k_grid, g(k_grid, params),  lw=2, alpha=0.6, label=lb)
    ax.plot(k_grid, k_grid, "k--", lw=1, alpha=0.7, label="45")

    # Show and annotate the fixed point
    kstar = exact_fixed_point(params)
    fps = (kstar,)
    ax.plot(fps, fps, "go", ms=10, alpha=0.6)
    ax.annotate(r"$k^* = (sA / \delta)^{\frac{1}{1-\alpha}}$", 
             xy=(kstar, kstar),
             xycoords="data",
             xytext=(20, -20),
             textcoords="offset points",
             fontsize=fontsize)

    ax.legend(loc="upper left", frameon=False, fontsize=fontsize)

    ax.set_yticks((0, 1, 2, 3))
    ax.set_yticklabels((0, 1, 2, 3), fontsize=fontsize)
    ax.set_ylim(0, 3)
    ax.set_xlabel("$k_t$", fontsize=fontsize)
    ax.set_ylabel("$k_{t+1}$", fontsize=fontsize)
```

Let's look at the 45 degree diagram for one or two parameterizations.

```{code-cell} python3
params = create_solow_params()
fig, ax = plt.subplots(figsize=(8, 8))
plot_45(params, ax)
plt.show()
```

```{code-cell} python3
params = create_solow_params(α=0.05, δ=0.5)
fig, ax = plt.subplots(figsize=(8, 8))
plot_45(params, ax)
plt.show()
```

Here's a time series from a particular choice of $k_0$.


```{code-cell} python3
def compute_iterates(k_0, f, params, n=25):
    "Compute time series of length n generated by arbitrary function f."
    k = k_0
    k_iterates = []
    for t in range(n):
        k_iterates.append(k)
        k = f(k, params)
    return k_iterates
```

```{code-cell} python3
params = create_solow_params()
k_0 = 0.25
k_series = compute_iterates(k_0, g, params)
k_star = exact_fixed_point(params)

fig, ax = plt.subplots()
ax.plot(k_series, 'o')
ax.plot([k_star] * len(k_series), 'k--')
ax.set_ylim(0, 3)
plt.show()
```

Since we are iterating on $g$, we are also implemening successive approximation.

```{code-cell} python3
k_series = compute_iterates(k_0, g, params, n=10_000)
k_star_approx = k_series[-1]
k_star_approx
```


```{code-cell} python3
k_star
```

## Newton's Method

To implement Newton's method we observe that

```{math}
:label: newton_method2

g'(k) = \alpha s A k^{1-\alpha} + (1-\delta)

```


```{code-cell} python3
def Dg(k, params):
    A, s, α, δ = params
    return α * A * s * k**(α-1) + (1 - δ)
```


Here's a function $q$ such that iterating with $q$ is equivalent to Newton's method.

```{code-cell} python3
def q(k, params):
    return (g(k, params) - Dg(k, params) * k) / (1 - Dg(k, params))
```

Now let's plot some trajectories.

```{code-cell} python3
def plot_trajectories(params, 
                      k0_a=0.8,  # first initial condition
                      k0_b=3.1,  # second initial condition
                      n=20,      # length of time series
                      fs=14):    # fontsize

    fig, axes = plt.subplots(2, 1, figsize=(10, 6))
    ax1, ax2 = axes

    ks1 = compute_iterates(k0_a, g, params, n)
    ax1.plot(ks1, "-o", label="successive approximation")

    ks2 = compute_iterates(k0_b, g, params, n)
    ax2.plot(ks2, "-o", label="successive approximation")

    ks3 = compute_iterates(k0_a, q, params, n)
    ax1.plot(ks3, "-o", label="newton steps")

    ks4 = compute_iterates(k0_b, q, params, n)
    ax2.plot(ks4, "-o", label="newton steps")

    for ax in axes:
        ax.plot(k_star * np.ones(n), "k--")
        ax.legend(fontsize=fs, frameon=False)
        ax.set_ylim(0.6, 3.2)
        ax.set_yticks((k_star,))
        ax.set_yticklabels(("$k^*$",), fontsize=fs)
        
    plt.show()
```

```{code-cell} python3
params = create_solow_params()
plot_trajectories(params)
```


## Multivariate Newton’s Method

In multi-dimentional setting, the [formula](newtons_method) is written as

```{math}
:label: newton_method_multi

x_{k+1} = (I - J(x_k))^{-1}(Tx_k - J(x_k)) x_k

```
Here $J(x) := $ the Jacobian of $T$ evaluated at $x$.


```{code-cell} python3
def create_multi_solow_params(A=2.0, s=0.3, α=0.3, δ=0.4):
    "Creates a Solow model parameterization with default values."
    return SolowParameters(A=A, s=s, α=α, δ=δ)
```
